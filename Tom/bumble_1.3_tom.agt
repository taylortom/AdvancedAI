% Bumble version 1.0: a sample agent file for the Virtual World system
%
% Author: Donald Nute
%
% Date created:  02/02/1998
% Last modified: 12/06/2005
%

%:- dynamic [agent/2,tried/0,pushed/0].
%:- dynamic [agent/2,tried/0,last/1,pushed/0,hungry/0,hurt/0].
:- dynamic [agent/2,tried/0,pushed/0,hungry/0,hurt/0,mymap/3,here/2,last_seen/3].

% agent(+Perceptions, -Action) receives set of Perceptions from the
% V-World simulator and returns an Action. Perceptions is a list of 
% the form
%
% [Strength,Damage,Inventory,Last,
%	[NWNW, NNW , NN  , NNE , NENE],
%	[WNW , NW  , N   , NE  , ENE ]
%	[WW  , W   , HERE, E   , EE  ],
%	[WSW , SW  , S   , SE  , ESE ],
%	[SWSW, SSW , SS  , SSE , SESE]]
% 
% where the last five items in the list lists comprising the contents
% of the 5 x 5 grid centered on the agent's current location (HERE).
% Inventory is also a list of the items the agent is currently holding.
% Last points in the direction of the location the agent last occupied.
% For example, if the agent tried successfully to move north at its
% last turn, then Last = s; but if the agent tried to move north and
% its movement was blocked, then Last = same.
%
% An agent cannot see through an opaque object. If its view of a cell
% is hidden by an object, the corresponding variable in its visual field
% has the value cant_see.

agent(Perceptions,Action) :-
	set_bumble_states(Perceptions),
	build_bumble_map(Perceptions),
	bumble(Perceptions,Action).

set_bumble_states([Strength,Damage|_]) :-
	is_bumble_hungry(Strength),
	is_bumble_hurt(Damage).

is_bumble_hungry(Strength) :-
	Strength < 1000,
	assert(hungry).

is_bumble_hungry(Strength) :-
	Strength > 3000,
	retractall(hungry).

is_bumble_hungry(Strength).

is_bumble_hurt(Damage) :-
	Damage > 50,
	assert(hurt).

is_bumble_hurt(Damage) :-
	Damage = 0,
	retractall(hurt).

is_bumble_hurt(Damage).


% Bumble generally goes through doors when he sees them, eats whatever
% he sees that can be eaten, picks up anything he can, pushes on everything
% he sees except walls and animate objects, runs away from animate objects,
% and otherwise tends to move in straight lines with random changes of 
% direction.

% Although Bumble can "see" everything within a 2-cell radius, he only
% pays attention to objects that are adjacent to his current location.

% Here are the instructions Bumble follows.

% Try to go through any nearby door if you didn't try to go through
% a door on the last move.

bumble([_,_,_,_,_,[_,NW,N,NE,_],[_,W,_,E,_],[_,SW,S,SE,_],_],move(Dir)) :-
	\+ retract(tried),
	member(door,[NW,N,NE,W,E,SW,S,SE],Num),
	assert(tried),
	member(Dir,[nw,n,ne,w,e,sw,s,se],Num).

% Move away from any threatening object if posible

bumble([_,_,_,_,_,[_,NW,N,NE,_],[_,W,_,E,_],[_,SW,S,SE,_],_],move(Dir)) :-
	member(Obj,[NW,N,NE,W,E,SW,S,SE]),
	threatening(Obj),
	away_from(Obj,[NW,N,NE,W,E,SW,S,SE],Dir).

% Consume any nearby fruit.

bumble([_,_,_,_,_,[_,NW,N,NE,_],[_,W,_,E,_],[_,SW,S,SE,_],_],move(Dir)) :-
	member(fruit,[NW,N,NE,W,E,SW,S,SE],Num),
	hungry,
	member(Dir,[nw,n,ne,w,e,sw,s,se],Num).

% Collect any nearby desirable object.

bumble([_,_,_,_,_,[_,NW,N,NE,_],[_,W,_,E,_],[_,SW,S,SE,_],_],move(Dir)) :-
	member(Obj,[NW,N,NE,W,E,SW,S,SE],Num),
	desirable(Obj),
	member(Dir,[nw,n,ne,w,e,sw,s,se],Num).

% Keys, bird seed, and bug spray are desirable.

desirable(bkey).
desirable(blukey).
desirable(ykey).
desirable(gkey).
desirable(pkey).
desirable(birdseed).
desirable(bugspray).

% Try pushing nearby interesting objects if it is a tree
% trees are interesting & should be pushed only if hungry

% Try pushing nearby interesting objects

bumble([_,_,_,_,_,[_,NW,N,NE,_],[_,W,_,E,_],[_,SW,S,SE,_],_],move(Dir)) :-
	
	\+ retract(pushed),
	member(Obj,[NW,N,NE,W,E,SW,S,SE],Num),
	interesting(Obj),
	\+ Obj = tree, 
	\+ Obj = cross,
	\+ Obj = hornet,
	member(Dir,[nw,n,ne,w,e,sw,s,se],Num),
	assert(pushed).


bumble([_,_,_,_,_,[_,NW,N,NE,_],[_,W,_,E,_],[_,SW,S,SE,_],_],move(Dir)) :-
	
	\+ retract(pushed),
	member(Obj,[NW,N,NE,W,E,SW,S,SE],Num),
	interesting(Obj),
	Obj = tree, 
	hungry,
	member(Dir,[nw,n,ne,w,e,sw,s,se],Num),
	assert(pushed).

% Ignore crosses if not hurt

bumble([_,_,_,_,_,[_,NW,N,NE,_],[_,W,_,E,_],[_,SW,S,SE,_],_],move(Dir)) :-
	
	\+ retract(pushed),
	member(Obj,[NW,N,NE,W,E,SW,S,SE],Num),
	interesting(Obj),
	Obj = cross,
	hurt,
	member(Dir,[nw,n,ne,w,e,sw,s,se],Num),
	assert(pushed).

% Ignore hornets if not hurt

bumble([_,_,_,_,_,[_,NW,N,NE,_],[_,W,_,E,_],[_,SW,S,SE,_],_],move(Dir)) :-
	
	\+ retract(pushed),
	member(Obj,[NW,N,NE,W,E,SW,S,SE],Num),
	interesting(Obj),
	Obj = hornet,
	\+ hurt,
	member(Dir,[nw,n,ne,w,e,sw,s,se],Num),
	assert(pushed).

% If there's a tree two squares away, move towards it
bumble([_,_,_,_,[NWNW,NNW,NN,NNE,NENE],[WNW,_,_,_,ENE],[WW,_,_,_,EE],[WSW,_,_,_,ESE],[SWSW,SSW,SS,SSE,SESE]],move(Dir)) :-
	
	member(Obj,[NWNW,NNW,NN,NNE,NENE,SWSW,SSW,SS,SSE,SESE,WNW,ENE,WW,EE,WSW,ESE],Num),
	interesting(Obj), % not sure if this is needed?
	Obj = tree, 
	hungry,
	member(GoToward,[nwnw,nnw,nn,nne,nene,swsw,ssw,ss,sse,sese,wnw,ww,wsw,ene,ee,ese],Num),
	move_toward_x(GoToward,Dir).

% If there's a tree two squares away, move towards it
bumble([_,_,_,_,[NWNW,NNW,NN,NNE,NENE],[WNW,_,_,_,ENE],[WW,_,_,_,EE],[WSW,_,_,_,ESE],[SWSW,SSW,SS,SSE,SESE]],move(Dir)) :-
	
	member(Obj,[NWNW,NNW,NN,NNE,NENE,SWSW,SSW,SS,SSE,SESE,WNW,ENE,WW,EE,WSW,ESE],Num),
	interesting(Obj), % not sure if this is needed?
	Obj = cross, 
	hurt,
	member(GoToward,[nwnw,nnw,nn,nne,nene,swsw,ssw,ss,sse,sese,wnw,ww,wsw,ene,ee,ese],Num),
	move_toward_x(GoToward,Dir).

% If there's something interesting two squares away, move towards it
bumble([_,_,_,_,[NWNW,NNW,NN,NNE,NENE],[WNW,_,_,_,ENE],[WW,_,_,_,EE],[WSW,_,_,_,ESE],[SWSW,SSW,SS,SSE,SESE]],move(Dir)) :-
	
	member(Obj,[NWNW,NNW,NN,NNE,NENE,SWSW,SSW,SS,SSE,SESE,WNW,ENE,WW,EE,WSW,ESE],Num),
	interesting(Obj), % not sure if this is needed?
	member(GoToward,[nwnw,nnw,nn,nne,nene,swsw,ssw,ss,sse,sese,wnw,ww,wsw,ene,ee,ese],Num),
	move_toward_x(GoToward,Dir).

% If there's something desirable two squares away, move towards it
bumble([_,_,_,_,[NWNW,NNW,NN,NNE,NENE],[WNW,_,_,_,ENE],[WW,_,_,_,EE],[WSW,_,_,_,ESE],[SWSW,SSW,SS,SSE,SESE]],move(Dir)) :-
	
	member(Obj,[NWNW,NNW,NN,NNE,NENE,SWSW,SSW,SS,SSE,SESE,WNW,ENE,WW,EE,WSW,ESE],Num),
	desirable(Obj), % not sure if this is needed?
	member(GoToward,[nwnw,nnw,nn,nne,nene,swsw,ssw,ss,sse,sese,wnw,ww,wsw,ene,ee,ese],Num),
	move_toward_x(GoToward,Dir).

/* Table of directions as specified in Nute's V-World
... Our Workshop 3
*/
	move_toward_x(nwnw,nw). % top left corner
	move_toward_x(nwnw,n).
	move_toward_x(nwnw,w).
	%
	move_toward_x(nene,ne). % top right corner
	move_toward_x(nene,n).
	move_toward_x(nene,e).
	%
	move_toward_x(swsw,sw). % bottom left corner
	move_toward_x(swsw,s).
	move_toward_x(swsw,w).
	
	%move_toward_x(sese,se). % botton right corner
	move_toward_x(sese,s).
	move_toward_x(sese,e).
	
	% a - top left of centre
	move_toward_x(nnw,w).
	move_toward_x(nnw,nw).
	
	% b - top centre
	move_toward_x(nn,n).
	move_toward_x(nn,nw).
	move_toward_x(nn,ne).
	
	% c - top right of centre
	move_toward_x(nne,n).
	move_toward_x(nne,ne).
	
	% d - bottom left of centre
	move_toward_x(ssw,s).
	move_toward_x(ssw,sw).
	
	% e - bottom centre
	move_toward_x(ss,s).
	move_toward_x(ss,sw).
	move_toward_x(ss,se).
	
	% f - bottom right of centre
	move_toward_x(sse,s).
	move_toward_x(sse,se).
	
	% g - left up from centre
	move_toward_x(wnw,w).
	move_toward_x(wnw,nw).
	
	% h - left centre
	move_toward_x(ww,w).
	move_toward_x(ww,nw).
	move_toward_x(ww,sw).
	
	% i - left below centre
	move_toward_x(wsw,w).
	move_toward_x(wsw,sw).

	% j - right up from centre
	move_toward_x(ene,e).
	move_toward_x(ene,ne).
	
	% k - right centre
	move_toward_x(ee,e).
	move_toward_x(ee,ne).
	move_toward_x(ene,se).
	
	% l - right below centre
	move_toward_x(ese,e).
	move_toward_x(ese,se).
	%%%%%%%%%%%%%% end of table of directions %%%%

% Trees, red croses, and birds are interesting.

interesting(tree).
interesting(cross).
interesting(bird).

% Hornets, snails, and thorns are threatening.

threatening(hornet).
threatening(snail).
threatening(thorn).

% About 87% of the time, move in the direction you went
% last if it is clear.

bumble([_,_,_,LastLocation,_,[_,NW,N,NE,_],[_,W,_,E,_],[_,SW,S,SE,_],_],move(Dir)) :-
	random_direction(X),
	member(X,[nw,n,ne,w,e,sw,s,se],Test),
	Test > 1,
	member(LastLocation,[se,s,sw,e,w,ne,n,nw],Num),
	member(Dir,[nw,n,ne,w,e,sw,s,se],Num),
	member(o,[NW,N,NE,W,E,SW,S,SE],Num).

% Move at random to empty space.

bumble([_,_,_,_,_,[_,NW,N,NE,_],[_,W,_,E,_],[_,SW,S,SE,_],_],move(Dir)) :-
	member(o,[NW,N,NE,W,E,SW,S,SE]),
	repeat,
	random_direction(Dir),
	member(Dir,[nw,n,ne,w,e,sw,s,se],Num2),
	member(o,[NW,N,NE,W,E,SW,S,SE],Num2).

% When all else fails, sit out a move.

bumble(_,sit).

%
%
%
% Map generation
%
%
%

build_bumble_map(Perceptions):-
	\+ here(_,_), !, % first time, no map
	assert(here(0,0)), % always starts at (0,0)
	assert(mymap(0,0,o)), % must be open space
	update_bumble_map(0,0,Perceptions).

build_bumble_map([_,_,_,Dir,_,_,_,_,_]):-
	Dir = same, ! . % no move - cut search - nothing

build_bumble_map([_,_,_,Dir,V1,V2,V3,V4,V5]):-
	\+ tried, !, % bumble did not go through a door last time
	here(X,Y),
	member(Dir,[nw,n,ne,e,se,s,sw,w],Pos),
	member((XX,YY),[(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1),(1,0)],Pos),
	NewX is X+XX,
	NewY is Y+YY,
	retractall(here(_,_)),
	assert(here(NewX,NewY)),
	update_bumble_map(NewX,NewY,[_,_,_,Dir,V1,V2,V3,V4,V5]).

update_bumble_map(BX,BY,[_,_,_,_,
			[NWNW,NNW,NN,NNE,NENE], % V1
			[WNW,NW,N,NE,ENE], % V2
			[WW,W,_,E,EE], % V3
			[WSW,SW,S,SE,ESE], % V4
			[SWSW,SSW,SS,SSE,SESE]]):- % V5
	here(BX,BY),
	findall((X,Y,Obj),
		(member(Obj,[NWNW,NNW,NN,NNE,NENE,
			WNW,NW,N,NE,ENE,WW,W,E,EE,
			WSW,SW,S,SE,ESE,SWSW,SSW,SS,SSE,SESE],Pos),
		member((XX,YY),[(-2,-2),(-1,-2),(0,-2),
			(1,-2),(2,-2),(-2,-1),(-1,-1),
			(0,-1),(1,-1),(2,-1),(-2,0),
			(-1,0),(1,0),(2,0),(-2,1),(-1,1),
			(0,1),(1,1),(2,1),(-2,2),(-1,2),
			(0,2),(1,2),(2,2)],Pos),
			X is BX+XX,
			Y is BY+YY ),
			List),
	update_bumble_map_x(List).

update_bumble_map_x([(X,Y,Obj)|RestOfList]):-
	\+ Obj = cant_see,
	\+ Obj = o,
	assert(mymap(X,Y,Obj)),
	write(Obj).	

update_bumble_map_x([_|RestOfList]):-
	update_bumble_map_x(RestOfList).
